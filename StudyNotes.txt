--------------------------------------------Day 1-----------------------------------------------

pom.xml - "build brain" defines (Java version, Dependencies, and Plugins)
Application.java - known as entry point and the component scan root (All packages should live under this package)
controller/ - HTTP boundary which handles (Requests, Responses, and Validation), doesn't talk to database directly 
service/ - business logic which handles (Rules, Decisions, Transactions)
repository/ - database access which handles (SQL,Fetching/saving data)
domain/-the data model which contains (JPA entities and Enums)
dto/ - API contracts which is used for Request and Response payloads (NEVER EXPOSE ENTITIES DIRECTLY IN APIs)
security/ - which contains (Security config, JWT filters, and Role handling)
config/ - which contains (Beans and App configuration)
exception/ - which contains (custom exceptions and global error handlers)
util/ - which contains (small helper classes)
resources/ folder - which contains application.yml(Config, Profiles[dev/test/prod]),
		    db/migration/ (Flyway SQL scripts and Versioned schema changes)
test/ - mirrors main/ files (Same package structure = easier testing)

Important rules to memorize 
*Controllers = HTTP only
*Services = logic + transactions
*Repositories = data access
*DTOs does not equal to entities
*Config does not equal to Logic
*Security is explicit 
*Everything lives under Application package
		    
@RestController - is an annotation that marks a Java class as a REST API controller. Here is what it does:
1.Identifies the class as a controller
2.Automatically serializes return values to JSON/XML

DTOs define API boundaries


---------------------------------------------------Day 2-----------------------------------

Controller maps HTTP -> DTO -> service -> DTO -> response

Why an HTTP folder?
-Keeps manual API tests separate from code
-Mirrors what real teams do
-Easy to version control
-clean root directory

src/main -> production code
src/tests -> automated tests
http/ -> manual API testing
README.md -> humans
NOTES.md -> learning + reference

REST controller basics
-@RestController maps HTTP Requests to Java methods
-@RequestMapping("/api/v1") defines a base path
-@GetMapping handles GET requests
-@PostMapping handles POST requests

DTOs (Data Transfer Object)
-DTOs define API contracts
-Separate request DTOs from response DTOs
-Never expose entities directly
-DTO field names must match JSON keys

Request body handling
-@RequestBody binds JSON to a java object
-Content-Type: application/json is required
-Missing or malformed JSON results in 400 Bad Request

Common HTTP Status meanings
-200 OK - success
-400 Bad Request - invalid input
-404 Not Found - path or method mismatch
-415 Unsupported media type - wrong Content-Type

Manual API testing tools
Postman
-Best for quick manual testing
-Requires correct method, URL, headers, and body 
-Hidden characters (e.g. %0A) can cause 404 errors
VS Code REST Client
-.http files stored in project root (http/ folder)
-Requests executed with "Send Request"
-Used as manual smoke tests
-Not automated tests
REST Client file structure
http -> api.http

-----------------------------Day 3 notes------------------------------------------------

Validation basics
-@Valid
-@NotBlank
-@Size
-@NotNull

Error handling
-Why Spring throws validation exceptions
-Why we centralize error handling with @ControllerAdvice
Validation happens at the boundary(controller), not in the service

@Valid tells Spring to enforce the annotations 

Input Validation (Spring Boot)

Why validation exists 
-APIs must reject bad input early
-Validation happens at the controller boundary
-Prevents bad data from entering business logic

Validation annotations
Used on DTO fields
@NotBlank // string must not be null or empty
@NotNull // value must not be null
@Size // length constraints

Enabling validation - Validation runs only when (@Valid @RequestBody Echo Request request)
-@Valid -> tells Spring to enforce annotations
-Without it, validation annotations are ignored

Validation failure behavior 
When validation fails:
-Spring throws MethodArgumentNotValidException
-Default error response is verbose and inconsistent
-We override it using @ControllerAdvice

Global Error Handling
@ControllerAdvice
-Applies to all controllers
-Centralizes exception handling
-Prevents duplicated try/catch blocks

@ExceptionHandler(MethodArgumentNotValidException.class)
@ResponseStatus(HttpStatus.BAD_REQUEST)
public ErrorResponse handleValidation(MethodArgumentNotValidException ex) {
What this means
-This method runs only when validation fails
-It catches MethodArgumentNotValidException
-It always returns HTTP 400 Bad Request

What is ex?
- ex - is the exception thrown by spring
- It contains details about what failed validation

getBindingResult():
-Holds all validation errors
-Field level + object level errors

.getFieldErrors()
-Returns a list of field errors
-Each error represents one invalid field

.stream()
-Converts the list into a stream
-Allows functional processing (map, collect)

.map(err -> err.getField() + ": " + err.getDefaultMessage())
For each field error:
-err.getField() -> field name (title)
-err.getDefaultMessage() -> validation message

.collect(Collectors.toList());
-Converts the stream back into a List<String>

Final result:
[
  "title: title is required",
  "priority: priority is required"
]

return new ErrorResponse(
	Instant.now(),
	400,
	"Bad Request",
	messages
)
What this does
-Builds a clean, structured error response
	Includes:
	-When the error happened
	-HTTP status
	-short description
	-detailed validation messages

End-to-end flow 
1.Client send bad JSON
2.Spring tries to bind JSON -> DTO
3.Validation fails
4.Spring throws MethodArgumentNotValidException
5.@ControllerAdvice catches it
6.handleValidation formats the response
7.Client receives clean 400 reponse

Why this is professional-grade code 
-No try/catch in controlers 
-No duplicated error logic
-Consistent response shape
-Scales to large applications
-Matches enterprise / DoD standards

What you should remember (Key takeaways)
-Validation belongs at the API boundary
-@Valid activates field annotations
-Exceptions are data, not crashes
-@ControllerAdvice = centralized control
-Streams are used to transform error data cleanly

Current project status
-REST endpoints working
-Validation enforced
-Errors standardized
-Manual tests passing
-Notes saved

Professional rule - If curl works, the backend is correct.
- CI pipelines use automated tests
- Engineers debug with curl
- Postman is just a convenience tool

Summary Notes Day 3
Understanding handleValidation()
-Extracted field-level validation errors from BindingResult
-Transformed them into user-readable messages
-Returned a clean, structured response
-Learned how stream operations map error data

Manual Testing & Tooling Reality
-Postman
-VS Code REST Client(.http)
-PowerShell (Invoke-WebRequest)
-Real curl (curl.exe)

Critical lesson - curl.exe is the source of truth on Windows
-PowerShell aliases curl -> Invoke-WebRequest
-Postman and REST Client can behave inconsistently with empty bodies
-Validation correctness was proven via terminal tests

HTTP Status Code Understanding
-200 OK -> Valid input
-400 Bad Request -> Validation failure
-404 Not Found -> route not matched / tool misfire
-Learned to distinguish backend bugs from tooling issues


